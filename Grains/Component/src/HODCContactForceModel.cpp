#include "HODCContactForceModel.hh"
#include "VectorMath.hh"


// -----------------------------------------------------------------------------
// Default constructor
template <typename T>
__HOSTDEVICE__
HODCContactForceModel<T>::HODCContactForceModel()
{}




// -----------------------------------------------------------------------------
// Constructor with an XML node
template <typename T>
__HOST__
HODCContactForceModel<T>::HODCContactForceModel( DOMNode* root )
{
    DOMNode* parameter;
    parameter = ReaderXML::getNode( root, "stiff" );
    m_stiff = T( ReaderXML::getNodeValue_Double( parameter ) );

    parameter = ReaderXML::getNode( root, "muc" );
    m_muec = T( ReaderXML::getNodeValue_Double( parameter ) ); 

    parameter = ReaderXML::getNode( root, "en" );
    m_en = T( ReaderXML::getNodeValue_Double( parameter ) ); 
    m_muen = T( log( m_en ) / sqrt( PI * PI + log( m_en ) * log( m_en ) ) ); 

    parameter = ReaderXML::getNode( root, "mut" );
    m_muet = T( ReaderXML::getNodeValue_Double( parameter ) ); 

    parameter = ReaderXML::getNode( root, "kms" );
    m_kms = T( ReaderXML::getNodeValue_Double( parameter ) ); 
}




// -----------------------------------------------------------------------------
// Constructor with five values as contact parameters
template <typename T>
__HOSTDEVICE__
HODCContactForceModel<T>::HODCContactForceModel( T stiff,
                                                 T en, 
                                                 T muet, 
                                                 T muec, 
                                                 T kms )
: m_stiff( stiff )
, m_en( en )
, m_muet( muet )
, m_muec( muec )
, m_kms( kms )                                     
{
    m_muen = log( m_en ) / sqrt( PI * PI + log( m_en ) * log( m_en ) ); 
}




// -----------------------------------------------------------------------------
// Destructor
template <typename T>
__HOSTDEVICE__
HODCContactForceModel<T>::~HODCContactForceModel()
{}




// -----------------------------------------------------------------------------
// Gets the total torque of the torce
template <typename T>
__HOSTDEVICE__
Vector3<T> Torce<T>::getTorque() const
{
    return ( m_torque );
}




// -----------------------------------------------------------------------------
// Performs forces & torques computation
template <typename T>
__HOSTDEVICE__
void HODCContactForceModel<T>::performForcesCalculus( 
                                        ContactInfo<T> const& contactInfos,
                                        Vector3<T> const& relVelocityAtContact,
                                        Vector3<T> const& relAngVelocity,
                                        T m1,
                                        T m2,
                                        Vector3<T>& delFN,
                                        Vector3<T>& delFT,
                                        Vector3<T>& delM ) const
{
    Vector3<T> geometricPointOfContact = contactInfos.getContactPoint();
    Vector3<T> penetration = contactInfos.getContactVector();
    

    // Normal linear elastic force
    // We do this here as we want to modify the penetration vector
    delFN = m_stiff * penetration;

    // Unit normal vector at contact point
    penetration /= norm( penetration );
    penetration.round();

    Vector3<T> v_n = ( relVelocityAtContact * penetration ) * penetration;
    Vector3<T> v_t = relVelocityAtContact - v_n;

    // Unit tangential vector along relative velocity at contact point 
    T normv_t = norm( v_t );
    Vector3<T> tangent = zeroVector3T;
    if ( normv_t > EPSILON1 )
        tangent = v_t / normv_t;
  
    // Normal dissipative force  
    T avmass = T( 2 ) * m1 * m2 / ( m1 + m2 );
    T omega0 = sqrt( T( 2 ) * m_stiff / avmass );
    if ( avmass == T( 0 ) ) 
    {
        avmass = m2 == T( 0 ) ? m1 : m2;
        omega0 = T( 2 ) * sqrt( m_stiff / avmass );
    }
    T muen = - omega0 * m_muen;
    delFN += - muen * avmass * v_n;
    T normFN = norm( delFN );
  
    // Tangential dissipative force
    delFT = ( -m_muet * avmass ) * v_t;  

    // Tangential Coulomb saturation
    T fn = m_muec * normFN;
    T ft = norm( delFT );
    if ( fn < ft ) 
        delFT = ( -fn ) * tangent;
  
    // Rolling resistance moment
    if ( m_kms )
    {
        // Relative angular velocity at contact point
        Vector3<T> wn = ( relAngVelocity * penetration ) * penetration;
        Vector3<T> wt = relAngVelocity - wn ;
        T normwt = norm( wt );

        // Anti-spinning effect along the normal wn
        delM = - m_kms * normFN * T( 0.001 ) * wn;
        
        // Classical rolling resistance moment
        if ( normwt > EPSILON1 )
            delM -= m_kms * normFN * wt;    
    }
}




// -----------------------------------------------------------------------------
// Returns a torce based on the contact information
template <typename T>
__HOSTDEVICE__
void HODCContactForceModel<T>::computeForces( 
                                        ContactInfo<T> const& contactInfos,
                                        Vector3<T> const& relVelocityAtContact,
                                        Vector3<T> const& relAngVelocity,
                                        T m1,
                                        T m2,
                                        Torce<T>& torce ) const
{
    // Compute contact force and torque
    Vector3<T> delFN, delFT, delM;
    performForcesCalculus( contactInfos,
                           relVelocityAtContact,
                           relAngVelocity,
                           m1,
                           m2,
                           delFN,
                           delFT, 
                           delM );

    Vector3<T> geometricPointOfContact = contactInfos.getContactPoint();
    torce.addForce( delFN + delFT, geometricPointOfContact );
    if ( m_kms )
        torce.addTorque( delM );
}




// -----------------------------------------------------------------------------
// Explicit instantiation
template class HODCContactForceModel<float>;
template class HODCContactForceModel<double>;